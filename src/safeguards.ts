import {KeeperRecord} from '@keeper-security/secrets-manager-core'

// Field types that should never be modified directly
const PROTECTED_FIELD_TYPES = new Set([
    'fileRef', // File references - managed by uploadFile
    'passkey', // Passkey fields - special handling required
    'oneTimeCode', // One-time codes - generated by system
    'recordRef', // References to other records
    'addressRef', // References to address records
    'cardRef' // References to payment card records
])

// Field types that require special validation
const SENSITIVE_FIELD_TYPES = new Set(['password', 'oneTimeCode', 'securityQuestion', 'pinCode', 'privateKey', 'secret'])

// Standard KSM field types
const VALID_FIELD_TYPES = new Set([
    'login',
    'password',
    'url',
    // 'fileRef', // Removed - this is in PROTECTED_FIELD_TYPES
    // 'oneTimeCode', // Removed - this is in PROTECTED_FIELD_TYPES
    'notes',
    'text',
    'multiline',
    'email',
    'phone',
    'secret',
    'note',
    'securityQuestion',
    // 'passkey', // Removed - this is in PROTECTED_FIELD_TYPES
    'pinCode',
    'address',
    'paymentCard',
    'bankAccount',
    'name',
    'birthDate',
    'date',
    'expirationDate',
    'keyPair',
    'host',
    'licenseNumber',
    'pamHostname',
    'pamResource',
    'databaseType',
    'directoryType',
    'checkbox',
    'schedule',
    'script'
    // 'recordRef', // Removed - this is in PROTECTED_FIELD_TYPES
    // 'addressRef', // Removed - this is in PROTECTED_FIELD_TYPES
    // 'cardRef' // Removed - this is in PROTECTED_FIELD_TYPES
])

export interface ValidationResult {
    valid: boolean
    errors: string[]
    warnings: string[]
}

export interface RecordIntegrityCheck {
    hasRequiredFields: boolean
    hasValidStructure: boolean
    missingFields: string[]
    invalidFields: string[]
}

/**
 * Validates if a field type can be modified
 */
export function canModifyFieldType(fieldType: string): boolean {
    return !PROTECTED_FIELD_TYPES.has(fieldType)
}

/**
 * Checks if a field type can be created when it doesn't exist
 * Standard fields like notes, text, etc. should be creatable
 * @param fieldType The field type to check
 * @returns true if the field can be created
 */
export function canCreateFieldType(fieldType: string): boolean {
    // Allow creation of all standard fields that aren't protected
    return canModifyFieldType(fieldType) && isValidFieldType(fieldType)
}

/**
 * Validates if a field type is recognized by KSM
 */
export function isValidFieldType(fieldType: string): boolean {
    return VALID_FIELD_TYPES.has(fieldType)
}

/**
 * Validates a value for a specific field type
 */
export function validateFieldValue(fieldType: string, value: string): ValidationResult {
    const errors: string[] = []
    const warnings: string[] = []

    // Check if field type is protected
    if (PROTECTED_FIELD_TYPES.has(fieldType)) {
        errors.push(`Field type '${fieldType}' is protected and cannot be modified directly`)
        return {valid: false, errors, warnings}
    }

    // Check if field type is valid - reject unknown field types
    if (!isValidFieldType(fieldType)) {
        errors.push(`Field type '${fieldType}' is not a recognized KSM field type and cannot be created`)
        return {valid: false, errors, warnings}
    }

    // Validate based on field type
    switch (fieldType) {
        case 'email':
            if (value && !isValidEmail(value)) {
                errors.push(`Invalid email format: ${value}`)
            }
            break

        case 'url':
            if (value && !isValidUrl(value)) {
                warnings.push(`Value doesn't appear to be a valid URL: ${value}`)
            }
            break

        case 'phone':
            if (value && !isValidPhone(value)) {
                warnings.push(`Value doesn't appear to be a valid phone number: ${value}`)
            }
            break

        case 'checkbox':
            if (value && value !== 'true' && value !== 'false') {
                errors.push(`Checkbox value must be 'true' or 'false', got: ${value}`)
            }
            break

        case 'date':
        case 'birthDate':
        case 'expirationDate':
            if (value && !isValidDate(value)) {
                errors.push(`Invalid date format. Expected ISO 8601 format, got: ${value}`)
            }
            break

        case 'password':
            if (!value) {
                warnings.push('Setting an empty password may lock you out of the account')
            } else if (value.length < 8) {
                warnings.push('Password is less than 8 characters - may not meet security requirements')
            }
            break

        case 'pinCode':
            if (value && !/^\d+$/.test(value)) {
                warnings.push('PIN code contains non-numeric characters')
            }
            break
    }

    // Check for sensitive fields
    if (SENSITIVE_FIELD_TYPES.has(fieldType) && value) {
        warnings.push(`Modifying sensitive field '${fieldType}' - ensure the value is correct`)
    }

    // Check value length limits
    if (value && value.length > 10000) {
        errors.push(`Value exceeds maximum length of 10000 characters`)
    }

    return {valid: errors.length === 0, errors, warnings}
}

/**
 * Checks the integrity of a record structure
 */
export function checkRecordIntegrity(record: KeeperRecord): RecordIntegrityCheck {
    const missingFields: string[] = []
    const invalidFields: string[] = []

    // Check basic structure
    if (!record.data) {
        return {
            hasRequiredFields: false,
            hasValidStructure: false,
            missingFields: ['data'],
            invalidFields: []
        }
    }

    // Check fields array exists
    if (!Array.isArray(record.data.fields)) {
        invalidFields.push('data.fields is not an array')
    }

    // Check record type
    const recordType = record.data.type
    const requiredFields = getRequiredFieldsForType(recordType)

    // Check for required fields based on record type
    if (record.data.fields) {
        const existingFieldTypes = new Set(record.data.fields.map((f: {type: string}) => f.type))

        for (const required of requiredFields) {
            if (!existingFieldTypes.has(required)) {
                missingFields.push(required)
            }
        }

        // Validate each field structure
        for (const field of record.data.fields) {
            if (!field.type) {
                invalidFields.push('Field missing type property')
            }
            if (!Array.isArray(field.value)) {
                invalidFields.push(`Field ${field.type} value is not an array`)
            }
        }
    }

    return {
        hasRequiredFields: missingFields.length === 0,
        hasValidStructure: invalidFields.length === 0,
        missingFields,
        invalidFields
    }
}

/**
 * Creates a backup of record fields
 */
export function createRecordBackup(record: KeeperRecord): {fields: {type: string; value: string[]}[]; custom: {type: string; value: string[]}[]; title?: string; type?: string} {
    return {
        fields: JSON.parse(JSON.stringify(record.data.fields || [])),
        custom: JSON.parse(JSON.stringify(record.data.custom || [])),
        title: record.data.title,
        type: record.data.type
    }
}

/**
 * Restores record fields from backup
 */
export function restoreRecordFromBackup(record: KeeperRecord, backup: {fields?: {type: string; value: string[]}[]; custom?: {type: string; value: string[]}[]}): void {
    if (backup.fields) {
        record.data.fields = JSON.parse(JSON.stringify(backup.fields))
    }
    if (backup.custom) {
        record.data.custom = JSON.parse(JSON.stringify(backup.custom))
    }
}

/**
 * Safely updates a field value with validation
 */
export function safeUpdateField(
    fields: {type: string; value: string[]}[],
    fieldType: string,
    value: string,
    allowCreate = true
): {success: boolean; error?: string; warning?: string} {
    // Validate the field can be modified
    if (!canModifyFieldType(fieldType)) {
        return {
            success: false,
            error: `Cannot modify protected field type: ${fieldType}`
        }
    }

    // Handle null/undefined fields array
    if (!fields || !Array.isArray(fields)) {
        return {
            success: false,
            error: 'Fields array is invalid or undefined'
        }
    }

    // Validate the value
    const validation = validateFieldValue(fieldType, value)
    if (!validation.valid) {
        return {
            success: false,
            error: validation.errors[0]
        }
    }

    // Find existing field - ensure we're checking valid objects
    const existingField = fields.find((f: {type: string; value: string[]}) => f && typeof f === 'object' && f.type === fieldType)

    if (existingField) {
        // Preserve existing value array structure if it exists
        if (!Array.isArray(existingField.value)) {
            existingField.value = []
        }
        // Update value - always store as array
        existingField.value = [value]
        return {
            success: true,
            warning: validation.warnings[0]
        }
    } else if (allowCreate) {
        // Create new field with proper structure
        const newField = {
            type: fieldType,
            value: [value] // Always store as array
        }

        // Validate the new field structure before adding
        if (!newField.type || !Array.isArray(newField.value)) {
            return {
                success: false,
                error: 'Failed to create valid field structure'
            }
        }

        fields.push(newField)
        return {
            success: true,
            warning: validation.warnings[0]
        }
    } else {
        return {
            success: false,
            error: `Field '${fieldType}' does not exist in this record. This integration does not support adding new fields at this time.`
        }
    }
}

/**
 * Sanitizes a field value to prevent corruption
 */
export function sanitizeFieldValue(value: unknown): string {
    // Handle null/undefined
    if (value === null || value === undefined) {
        return ''
    }

    // Handle arrays - take first element
    if (Array.isArray(value)) {
        return value.length > 0 ? String(value[0]) : ''
    }

    // Handle objects - stringify
    if (typeof value === 'object') {
        try {
            return JSON.stringify(value)
        } catch {
            return String(value)
        }
    }

    // Convert to string
    return String(value)
}

/**
 * Validates field array structure
 */
export function validateFieldsArray(fields: unknown): boolean {
    if (!Array.isArray(fields)) {
        return false
    }

    for (const field of fields) {
        if (!field || typeof field !== 'object') {
            return false
        }
        if (!field.type || typeof field.type !== 'string') {
            return false
        }
        if (!Array.isArray(field.value)) {
            return false
        }
    }

    return true
}

// Helper functions
function isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
}

function isValidUrl(url: string): boolean {
    try {
        new URL(url)
        return true
    } catch {
        // Check if it's a relative URL or protocol-less
        return /^(\/|www\.|[a-zA-Z0-9-]+\.)/.test(url)
    }
}

function isValidPhone(phone: string): boolean {
    // Very basic phone validation - just check for digits and common separators
    const phoneRegex = /^[\d\s\-+().]+$/
    return phoneRegex.test(phone) && phone.replace(/\D/g, '').length >= 7
}

function isValidDate(date: string): boolean {
    // Check ISO 8601 format
    const d = new Date(date)
    return !isNaN(d.getTime())
}

function getRequiredFieldsForType(recordType: string): string[] {
    switch (recordType) {
        case 'login':
            return ['login', 'password']
        case 'bankAccount':
            return ['bankAccount']
        case 'paymentCard':
            return ['paymentCard']
        case 'sshKey':
            return ['keyPair']
        default:
            return []
    }
}
