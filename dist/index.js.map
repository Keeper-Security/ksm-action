{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC15BA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":["../webpack://ksm-action/./lib/main.js","../webpack://ksm-action/./node_modules/@actions/core/lib/command.js","../webpack://ksm-action/./node_modules/@actions/core/lib/core.js","../webpack://ksm-action/./node_modules/@actions/core/lib/file-command.js","../webpack://ksm-action/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://ksm-action/./node_modules/@actions/core/lib/utils.js","../webpack://ksm-action/./node_modules/@actions/http-client/auth.js","../webpack://ksm-action/./node_modules/@actions/http-client/index.js","../webpack://ksm-action/./node_modules/@actions/http-client/proxy.js","../webpack://ksm-action/./node_modules/@keeper-security/secrets-manager-core/dist/index.cjs.js","../webpack://ksm-action/./node_modules/tunnel/index.js","../webpack://ksm-action/./node_modules/tunnel/lib/tunnel.js","../webpack://ksm-action/external node-commonjs \"assert\"","../webpack://ksm-action/external node-commonjs \"crypto\"","../webpack://ksm-action/external node-commonjs \"events\"","../webpack://ksm-action/external node-commonjs \"fs\"","../webpack://ksm-action/external node-commonjs \"http\"","../webpack://ksm-action/external node-commonjs \"https\"","../webpack://ksm-action/external node-commonjs \"net\"","../webpack://ksm-action/external node-commonjs \"os\"","../webpack://ksm-action/external node-commonjs \"path\"","../webpack://ksm-action/external node-commonjs \"tls\"","../webpack://ksm-action/external node-commonjs \"util\"","../webpack://ksm-action/webpack/bootstrap","../webpack://ksm-action/webpack/runtime/compat","../webpack://ksm-action/webpack/before-startup","../webpack://ksm-action/webpack/startup","../webpack://ksm-action/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRecordUids = exports.parseSecretsInputs = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst fs = __importStar(require(\"fs\"));\nconst secrets_manager_core_1 = require(\"@keeper-security/secrets-manager-core\");\nvar DestinationType;\n(function (DestinationType) {\n    DestinationType[DestinationType[\"output\"] = 0] = \"output\";\n    DestinationType[DestinationType[\"environment\"] = 1] = \"environment\";\n    DestinationType[DestinationType[\"file\"] = 2] = \"file\";\n})(DestinationType || (DestinationType = {}));\nconst parseSecretsInputs = (inputs) => {\n    const results = [];\n    for (const input of inputs) {\n        const inputParts = input.split(/\\s*>\\s*/);\n        let destinationType = DestinationType.output;\n        let destination = inputParts[1];\n        if (destination.startsWith('env:')) {\n            destinationType = DestinationType.environment;\n            destination = destination.slice(4);\n        }\n        else if (destination.startsWith('file:')) {\n            destinationType = DestinationType.file;\n            destination = destination.slice(5);\n        }\n        if (inputParts[0].split('/')[1] === 'file') {\n            destinationType = DestinationType.file;\n        }\n        results.push({\n            notation: inputParts[0],\n            destination,\n            destinationType\n        });\n    }\n    return results;\n};\nexports.parseSecretsInputs = parseSecretsInputs;\nconst getRecordUids = (inputs) => {\n    const set = new Set();\n    for (const input of inputs) {\n        set.add(input.notation.split('/')[0]);\n    }\n    return Array.from(set);\n};\nexports.getRecordUids = getRecordUids;\nconst downloadSecretFile = (file, destination) => __awaiter(void 0, void 0, void 0, function* () {\n    const fileData = yield (0, secrets_manager_core_1.downloadFile)(file);\n    fs.writeFileSync(destination, fileData);\n});\nconst run = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const config = core.getInput('keeper-secret-config');\n        const inputs = (0, exports.parseSecretsInputs)(core.getMultilineInput('secrets'));\n        const secrets = yield (0, secrets_manager_core_1.getSecrets)({ storage: (0, secrets_manager_core_1.loadJsonConfig)(config) }, (0, exports.getRecordUids)(inputs));\n        for (const input of inputs) {\n            const secret = (0, secrets_manager_core_1.getValue)(secrets, input.notation);\n            core.setSecret(secret);\n            switch (input.destinationType) {\n                case DestinationType.output:\n                    core.setOutput(input.destination, secret);\n                    break;\n                case DestinationType.environment:\n                    core.exportVariable(input.destination, secret);\n                    break;\n                case DestinationType.file:\n                    yield downloadSecretFile(secret, input.destination);\n                    break;\n            }\n        }\n    }\n    catch (error) {\n        let errorMessage = 'Failed getting secrets from Keeper Secrets Manager';\n        if (error instanceof Error) {\n            errorMessage = error.message;\n        }\n        core.setFailed(errorMessage);\n    }\n});\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","/* Version: 16.2.3 - February 9, 2022 23:47:55 */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar https = require('https');\nvar crypto = require('crypto');\nvar fs = require('fs');\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar fs__namespace = /*#__PURE__*/_interopNamespace(fs);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction connectPlatform(p) {\r\n    exports.platform = p;\r\n}\r\nexports.platform = void 0;\r\nconst loadJsonConfig = (config) => {\r\n    let jsonStr = config;\r\n    try {\r\n        const str = exports.platform.bytesToString(exports.platform.base64ToBytes(config));\r\n        if (str.trimStart().startsWith('{') && str.trimEnd().endsWith('}'))\r\n            jsonStr = str;\r\n    }\r\n    catch (e) {\r\n        jsonStr = config;\r\n    }\r\n    return inMemoryStorage(JSON.parse(jsonStr));\r\n};\r\nconst inMemoryStorage = (storage) => {\r\n    const getValue = (key) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts) {\r\n            obj = obj[part];\r\n            if (!obj) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return obj.toString();\r\n    };\r\n    const saveValue = (key, value) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts.slice(0, -1)) {\r\n            if (!obj[part]) {\r\n                obj[part] = {};\r\n            }\r\n            obj = obj[part];\r\n        }\r\n        obj[keyParts.slice(-1)[0]] = value;\r\n    };\r\n    const clearValue = (key) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts.slice(0, -1)) {\r\n            if (!obj[part]) {\r\n                obj[part] = {};\r\n            }\r\n            obj = obj[part];\r\n        }\r\n        delete obj[keyParts.slice(-1)[0]];\r\n    };\r\n    return {\r\n        getString: key => Promise.resolve(getValue(key)),\r\n        saveString: (key, value) => {\r\n            saveValue(key, value);\r\n            return Promise.resolve();\r\n        },\r\n        getBytes: key => {\r\n            const bytesString = getValue(key);\r\n            if (bytesString) {\r\n                return Promise.resolve(exports.platform.base64ToBytes(bytesString));\r\n            }\r\n            else {\r\n                return Promise.resolve(undefined);\r\n            }\r\n        },\r\n        saveBytes: (key, value) => {\r\n            const bytesString = exports.platform.bytesToBase64(value);\r\n            saveValue(key, bytesString);\r\n            return Promise.resolve();\r\n        },\r\n        delete: (key) => {\r\n            clearValue(key);\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n};\n\nconst webSafe64 = (source) => source.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\r\nconst webSafe64ToRegular = (source) => source.replace(/-/g, '+').replace(/_/g, '/') + '=='.substring(0, (3 * source.length) % 4);\r\nconst webSafe64ToBytes = (source) => exports.platform.base64ToBytes(webSafe64ToRegular(source));\r\nconst webSafe64FromBytes = (source) => webSafe64(exports.platform.bytesToBase64(source));\r\n// extracts public raw from private key for prime256v1 curve in der/pkcs8\r\n// privateKey: key.slice(36, 68)\r\nconst privateDerToPublicRaw = (key) => key.slice(-65);\r\nconst b32encode = (base32Text) => {\r\n    /* encodes a string s to base32 and returns the encoded string */\r\n    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\r\n    // private static readonly Regex rxBase32Alphabet = new Regex($\"\", RegexOptions.Compiled);\r\n    // The padding specified in RFC 3548 section 2.2 is not required and should be omitted.\r\n    const base32 = (base32Text || '').replace(/=+$/g, '').toUpperCase();\r\n    if (!base32 || !/^[A-Z2-7]+$/.test(base32))\r\n        return new Uint8Array();\r\n    const bytes = Array.from(base32);\r\n    let output = new Array();\r\n    for (let bitIndex = 0; bitIndex < base32.length * 5; bitIndex += 8) {\r\n        const idx = Math.floor(bitIndex / 5);\r\n        let dualByte = alphabet.indexOf(bytes[idx]) << 10;\r\n        if (idx + 1 < bytes.length)\r\n            dualByte |= alphabet.indexOf(bytes[idx + 1]) << 5;\r\n        if (idx + 2 < bytes.length)\r\n            dualByte |= alphabet.indexOf(bytes[idx + 2]);\r\n        dualByte = 0xff & (dualByte >> (15 - bitIndex % 5 - 8));\r\n        output.push(dualByte);\r\n    }\r\n    return new Uint8Array(output);\r\n};\r\nconst getTotpCode = (url, unixTimeSeconds = 0) => __awaiter(void 0, void 0, void 0, function* () {\r\n    let totpUrl;\r\n    try {\r\n        totpUrl = new URL(url);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n    if (totpUrl.protocol != 'otpauth:')\r\n        return null;\r\n    const secret = (totpUrl.searchParams.get('secret') || '').trim();\r\n    if (!secret)\r\n        return null;\r\n    let algorithm = (totpUrl.searchParams.get('algorithm') || '').trim();\r\n    if (!algorithm)\r\n        algorithm = 'SHA1'; // default algorithm\r\n    const strDigits = (totpUrl.searchParams.get('digits') || '').trim();\r\n    let digits = (isNaN(+strDigits) ? 6 : parseInt(strDigits));\r\n    digits = digits == 0 ? 6 : digits;\r\n    const strPeriod = (totpUrl.searchParams.get('period') || '').trim();\r\n    let period = (isNaN(+strPeriod) ? 30 : parseInt(strPeriod));\r\n    period = period == 0 ? 30 : period;\r\n    const tmBase = unixTimeSeconds != 0 ? unixTimeSeconds : Math.floor(Date.now() / 1000);\r\n    const tm = BigInt(Math.floor(tmBase / period));\r\n    const buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setBigInt64(0, tm);\r\n    const msg = new Uint8Array(buffer);\r\n    const secretBytes = b32encode(secret.toUpperCase());\r\n    if (secretBytes == null || secretBytes.length < 1)\r\n        return null;\r\n    const digest = yield exports.platform.getHmacDigest(algorithm, secretBytes, msg);\r\n    if (digest.length < 1)\r\n        return null;\r\n    const offset = digest[digest.length - 1] & 0x0f;\r\n    const codeBytes = new Uint8Array(digest.slice(offset, offset + 4));\r\n    codeBytes[0] &= 0x7f;\r\n    let codeInt = new DataView(codeBytes.buffer).getInt32(0);\r\n    codeInt %= Math.floor(Math.pow(10, digits));\r\n    codeInt = Math.floor(codeInt);\r\n    let codeStr = codeInt.toString(10);\r\n    while (codeStr.length < digits)\r\n        codeStr = \"0\" + codeStr;\r\n    const elapsed = Math.floor(tmBase % period); // time elapsed in current period in seconds\r\n    const ttl = period - elapsed; // time to live in seconds\r\n    return { code: codeStr, timeLeft: ttl, period: period };\r\n});\r\nconst generatePassword = (length = 64, lowercase = 0, uppercase = 0, digits = 0, specialCharacters = 0) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const asciiLowercase = 'abcdefghijklmnopqrstuvwxyz';\r\n    const asciiUppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    const asciiDigits = '0123456789';\r\n    const asciiSpecialCharacters = '\"!@#$%()+;<>=?[]{}^.,';\r\n    length = (typeof length === 'number' && length > 0) ? length : 64;\r\n    lowercase = (typeof lowercase === 'number' && lowercase > 0) ? lowercase : 0;\r\n    uppercase = (typeof uppercase === 'number' && uppercase > 0) ? uppercase : 0;\r\n    digits = (typeof digits === 'number' && digits > 0) ? digits : 0;\r\n    specialCharacters = (typeof specialCharacters === 'number' && specialCharacters > 0) ? specialCharacters : 0;\r\n    if (lowercase == 0 && uppercase == 0 && digits == 0 && specialCharacters == 0) {\r\n        const increment = length / 4;\r\n        const lastIncrement = increment + length % 4;\r\n        lowercase = uppercase = digits = increment;\r\n        specialCharacters = lastIncrement;\r\n    }\r\n    let result = '';\r\n    for (let i = 0; i < lowercase; i++)\r\n        result += yield exports.platform.getRandomCharacterInCharset(asciiLowercase);\r\n    for (let i = 0; i < uppercase; i++)\r\n        result += yield exports.platform.getRandomCharacterInCharset(asciiUppercase);\r\n    for (let i = 0; i < digits; i++)\r\n        result += yield exports.platform.getRandomCharacterInCharset(asciiDigits);\r\n    for (let i = 0; i < specialCharacters; i++)\r\n        result += yield exports.platform.getRandomCharacterInCharset(asciiSpecialCharacters);\r\n    // Fisher-Yates shuffle\r\n    if (result.length > 1) {\r\n        let a = result.split('');\r\n        for (let i = a.length - 1; i > 0; i--) {\r\n            const j = yield exports.platform.getRandomNumber(i + 1); // 0 <= j <= i\r\n            if (i != j) {\r\n                const tmp = a[i];\r\n                a[i] = a[j];\r\n                a[j] = tmp;\r\n            }\r\n        }\r\n        result = a.join('');\r\n    }\r\n    return result;\r\n});\n\nconst bytesToBase64 = (data) => Buffer.from(data).toString('base64');\r\nconst base64ToBytes = (data) => Buffer.from(data, 'base64');\r\nconst bytesToString = (data) => Buffer.from(data).toString();\r\nconst stringToBytes = (data) => Buffer.from(data);\r\nconst getRandomBytes = (length) => crypto.randomBytes(length);\r\nconst keyCache = {};\r\nconst loadKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const cachedKey = keyCache[keyId];\r\n    if (cachedKey) {\r\n        return cachedKey;\r\n    }\r\n    const keyBytes = storage\r\n        ? yield storage.getBytes(keyId)\r\n        : undefined;\r\n    if (!keyBytes) {\r\n        throw new Error(`Unable to load the key ${keyId}`);\r\n    }\r\n    keyCache[keyId] = keyBytes;\r\n    return keyBytes;\r\n});\r\nconst generateKeeperKeyPair = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => {\r\n        crypto.generateKeyPair('ec', {\r\n            namedCurve: 'prime256v1'\r\n        }, (err, publicKey, privateKey) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve(privateKey.export({\r\n                    format: 'der',\r\n                    type: 'pkcs8'\r\n                }));\r\n            }\r\n        });\r\n    });\r\n});\r\nconst generatePrivateKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield generateKeeperKeyPair();\r\n    keyCache[keyId] = privateKeyDer;\r\n    yield storage.saveBytes(keyId, privateKeyDer);\r\n});\r\nconst exportPublicKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield loadKey(keyId, storage);\r\n    return privateDerToPublicRaw(privateKeyDer);\r\n});\r\nconst privateDerToPEM = (key) => {\r\n    const rawPrivate = key.slice(36, 68);\r\n    const rawPublic = key.slice(-65);\r\n    const keyData1 = Buffer.of(0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20);\r\n    const keyData2 = Buffer.of(0xa0, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00);\r\n    return `-----BEGIN EC PRIVATE KEY-----\\n${bytesToBase64(Buffer.concat([keyData1, rawPrivate, keyData2, rawPublic]))}\\n-----END EC PRIVATE KEY-----`;\r\n};\r\nconst sign = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield loadKey(keyId, storage);\r\n    const key = privateDerToPEM(privateKeyDer);\r\n    // TODO revert to using createPrivateKey when node 10 interop is not needed anymore\r\n    // const key = createPrivateKey({\r\n    //     key: Buffer.from(privateKeyDer),\r\n    //     format: 'der',\r\n    //     type: 'pkcs8',\r\n    // })\r\n    const sign = crypto.createSign('SHA256');\r\n    sign.update(data);\r\n    const sig = sign.sign(key);\r\n    return Promise.resolve(sig);\r\n});\r\nconst importKey = (keyId, key, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    keyCache[keyId] = key;\r\n    if (storage) {\r\n        yield storage.saveBytes(keyId, key);\r\n    }\r\n});\r\nconst encrypt = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const key = yield loadKey(keyId, storage);\r\n    const iv = getRandomBytes(12);\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\r\n    const tag = cipher.getAuthTag();\r\n    return Buffer.concat([iv, encrypted, tag]);\r\n});\r\nconst _encrypt = (data, key) => {\r\n    const iv = crypto.randomBytes(12);\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\r\n    const tag = cipher.getAuthTag();\r\n    const result = Buffer.concat([iv, encrypted, tag]);\r\n    return Promise.resolve(result);\r\n};\r\nconst _decrypt = (data, key) => {\r\n    const iv = data.subarray(0, 12);\r\n    const encrypted = data.subarray(12, data.length - 16);\r\n    const tag = data.subarray(data.length - 16);\r\n    const cipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\r\n    cipher.setAuthTag(tag);\r\n    return Promise.resolve(Buffer.concat([cipher.update(encrypted), cipher.final()]));\r\n};\r\nconst unwrap = (key, keyId, unwrappingKeyId, storage, memoryOnly) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const unwrappingKey = yield loadKey(unwrappingKeyId, storage);\r\n    const unwrappedKey = yield _decrypt(key, unwrappingKey);\r\n    keyCache[keyId] = unwrappedKey;\r\n    if (memoryOnly) {\r\n        return;\r\n    }\r\n    if (storage) {\r\n        yield storage.saveBytes(keyId, unwrappedKey);\r\n    }\r\n});\r\nconst decrypt = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const key = yield loadKey(keyId, storage);\r\n    return _decrypt(data, key);\r\n});\r\nfunction hash(data) {\r\n    const hash = crypto.createHmac('sha512', data).update('KEEPER_SECRETS_MANAGER_CLIENT_ID').digest();\r\n    return Promise.resolve(hash);\r\n}\r\nconst publicEncrypt = (data, key, id) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const ecdh = crypto.createECDH('prime256v1');\r\n    ecdh.generateKeys();\r\n    const ephemeralPublicKey = ecdh.getPublicKey();\r\n    const sharedSecret = ecdh.computeSecret(key);\r\n    const sharedSecretCombined = Buffer.concat([sharedSecret, id || new Uint8Array()]);\r\n    const symmetricKey = crypto.createHash('SHA256').update(sharedSecretCombined).digest();\r\n    const encryptedData = yield _encrypt(data, symmetricKey);\r\n    return Buffer.concat([ephemeralPublicKey, encryptedData]);\r\n});\r\nconst fetchData = (res, resolve) => {\r\n    const retVal = {\r\n        statusCode: res.statusCode,\r\n        headers: res.headers,\r\n        data: null\r\n    };\r\n    res.on('data', data => {\r\n        retVal.data = retVal.data\r\n            ? Buffer.concat([retVal.data, data])\r\n            : data;\r\n    });\r\n    res.on('end', () => {\r\n        resolve(retVal);\r\n    });\r\n};\r\nconst get = (url, headers) => new Promise((resolve, reject) => {\r\n    const get = https.request(url, {\r\n        method: 'get',\r\n        headers: Object.assign({ 'User-Agent': `Node/${process.version}` }, headers)\r\n    }, (res) => {\r\n        fetchData(res, resolve);\r\n    });\r\n    get.on('error', reject);\r\n    get.end();\r\n});\r\nconst post = (url, payload, headers, allowUnverifiedCertificate) => new Promise((resolve, reject) => {\r\n    const options = {\r\n        rejectUnauthorized: !allowUnverifiedCertificate\r\n    };\r\n    const post = https.request(url, Object.assign(Object.assign({ method: 'post' }, options), { headers: Object.assign({ 'Content-Type': 'application/octet-stream', 'Content-Length': payload.length, 'User-Agent': `Node/${process.version}` }, headers) }), (res) => {\r\n        fetchData(res, resolve);\r\n    });\r\n    post.on('error', reject);\r\n    post.write(payload);\r\n    post.end();\r\n});\r\nconst cleanKeyCache = () => {\r\n    for (const key in keyCache) {\r\n        delete keyCache[key];\r\n    }\r\n};\r\nconst hasKeysCached = () => {\r\n    return Object.keys(keyCache).length > 0;\r\n};\r\nconst getHmacDigest = (algorithm, secret, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    // although once part of Google Key Uri Format - https://github.com/google/google-authenticator/wiki/Key-Uri-Format/_history\r\n    // removed MD5 as unreliable - only digests of length >= 20 can be used (MD5 has a digest length of 16)\r\n    let digest = new Uint8Array();\r\n    const algo = algorithm.toUpperCase().trim();\r\n    if (['SHA1', 'SHA256', 'SHA512'].includes(algo))\r\n        digest = crypto.createHmac(algo, secret).update(message).digest();\r\n    return Promise.resolve(digest);\r\n});\r\n// Returns a sufficiently random number in the range [0, max) i.e. 0 <= number < max\r\nconst getRandomNumber = (n) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const uint32Max = Math.pow(2, 32) - 1;\r\n    const limit = uint32Max - uint32Max % n;\r\n    let values = new Uint32Array(1);\r\n    do {\r\n        const randomBytes = getRandomBytes(4);\r\n        values = new Uint32Array(randomBytes.buffer);\r\n    } while (values[0] > limit);\r\n    return Promise.resolve(values[0] % n);\r\n});\r\n// Given a character set, this function will return one sufficiently random character from the charset.\r\nconst getRandomCharacterInCharset = (charset) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const count = charset.length;\r\n    const pos = yield getRandomNumber(count);\r\n    return Promise.resolve(charset[pos]);\r\n});\r\nconst nodePlatform = {\r\n    bytesToBase64: bytesToBase64,\r\n    base64ToBytes: base64ToBytes,\r\n    bytesToString: bytesToString,\r\n    stringToBytes: stringToBytes,\r\n    getRandomBytes: getRandomBytes,\r\n    generatePrivateKey: generatePrivateKey,\r\n    exportPublicKey: exportPublicKey,\r\n    importKey: importKey,\r\n    unwrap: unwrap,\r\n    encrypt: encrypt,\r\n    encryptWithKey: _encrypt,\r\n    decrypt: decrypt,\r\n    decryptWithKey: _decrypt,\r\n    hash: hash,\r\n    publicEncrypt: publicEncrypt,\r\n    sign: sign,\r\n    get: get,\r\n    post: post,\r\n    cleanKeyCache: cleanKeyCache,\r\n    hasKeysCached: hasKeysCached,\r\n    getHmacDigest: getHmacDigest,\r\n    getRandomNumber: getRandomNumber,\r\n    getRandomCharacterInCharset: getRandomCharacterInCharset\r\n};\n\nlet packageVersion = '16.2.3';\r\nconst KEY_HOSTNAME = 'hostname'; // base url for the Secrets Manager service\r\nconst KEY_SERVER_PUBIC_KEY_ID = 'serverPublicKeyId';\r\nconst KEY_CLIENT_ID = 'clientId';\r\nconst KEY_CLIENT_KEY = 'clientKey'; // The key that is used to identify the client before public key\r\nconst KEY_APP_KEY = 'appKey'; // The application key with which all secrets are encrypted\r\nconst KEY_OWNER_PUBLIC_KEY = 'appOwnerPublicKey'; // The application owner public key, to create records\r\nconst KEY_PRIVATE_KEY = 'privateKey'; // The client's private key\r\nconst CLIENT_ID_HASH_TAG = 'KEEPER_SECRETS_MANAGER_CLIENT_ID'; // Tag for hashing the client key to client id\r\nlet keeperPublicKeys;\r\nconst initialize = (pkgVersion) => {\r\n    if (pkgVersion) {\r\n        packageVersion = pkgVersion;\r\n    }\r\n    let keyNumber = 7;\r\n    keeperPublicKeys = [\r\n        'BK9w6TZFxE6nFNbMfIpULCup2a8xc6w2tUTABjxny7yFmxW0dAEojwC6j6zb5nTlmb1dAx8nwo3qF7RPYGmloRM',\r\n        'BKnhy0obglZJK-igwthNLdknoSXRrGB-mvFRzyb_L-DKKefWjYdFD2888qN1ROczz4n3keYSfKz9Koj90Z6w_tQ',\r\n        'BAsPQdCpLIGXdWNLdAwx-3J5lNqUtKbaOMV56hUj8VzxE2USLHuHHuKDeno0ymJt-acxWV1xPlBfNUShhRTR77g',\r\n        'BNYIh_Sv03nRZUUJveE8d2mxKLIDXv654UbshaItHrCJhd6cT7pdZ_XwbdyxAOCWMkBb9AZ4t1XRCsM8-wkEBRg',\r\n        'BA6uNfeYSvqagwu4TOY6wFK4JyU5C200vJna0lH4PJ-SzGVXej8l9dElyQ58_ljfPs5Rq6zVVXpdDe8A7Y3WRhk',\r\n        'BMjTIlXfohI8TDymsHxo0DqYysCy7yZGJ80WhgOBR4QUd6LBDA6-_318a-jCGW96zxXKMm8clDTKpE8w75KG-FY',\r\n        'BJBDU1P1H21IwIdT2brKkPqbQR0Zl0TIHf7Bz_OO9jaNgIwydMkxt4GpBmkYoprZ_DHUGOrno2faB7pmTR7HhuI',\r\n        'BJFF8j-dH7pDEw_U347w2CBM6xYM8Dk5fPPAktjib-opOqzvvbsER-WDHM4ONCSBf9O_obAHzCyygxmtpktDuiE',\r\n        'BDKyWBvLbyZ-jMueORl3JwJnnEpCiZdN7yUvT0vOyjwpPBCDf6zfL4RWzvSkhAAFnwOni_1tQSl8dfXHbXqXsQ8',\r\n        'BDXyZZnrl0tc2jdC5I61JjwkjK2kr7uet9tZjt8StTiJTAQQmnVOYBgbtP08PWDbecxnHghx3kJ8QXq1XE68y8c',\r\n        'BFX68cb97m9_sweGdOVavFM3j5ot6gveg6xT4BtGahfGhKib-zdZyO9pwvv1cBda9ahkSzo1BQ4NVXp9qRyqVGU'\r\n    ].reduce((keys, key) => {\r\n        keys[keyNumber++] = webSafe64ToBytes(key);\r\n        return keys;\r\n    }, {});\r\n};\r\nconst prepareGetPayload = (storage, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (!clientId) {\r\n        throw new Error('Client Id is missing from the configuration');\r\n    }\r\n    const payload = {\r\n        clientVersion: 'ms' + packageVersion,\r\n        clientId: clientId\r\n    };\r\n    const appKey = yield storage.getBytes(KEY_APP_KEY);\r\n    if (!appKey) {\r\n        const publicKey = yield exports.platform.exportPublicKey(KEY_PRIVATE_KEY, storage);\r\n        payload.publicKey = exports.platform.bytesToBase64(publicKey);\r\n    }\r\n    if (recordsFilter) {\r\n        payload.requestedRecords = recordsFilter;\r\n    }\r\n    return payload;\r\n});\r\nconst prepareUpdatePayload = (storage, record) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (!clientId) {\r\n        throw new Error('Client Id is missing from the configuration');\r\n    }\r\n    const recordBytes = exports.platform.stringToBytes(JSON.stringify(record.data));\r\n    const encryptedRecord = yield exports.platform.encrypt(recordBytes, record.recordUid);\r\n    return {\r\n        clientVersion: 'ms' + packageVersion,\r\n        clientId: clientId,\r\n        recordUid: record.recordUid,\r\n        data: webSafe64FromBytes(encryptedRecord),\r\n        revision: record.revision\r\n    };\r\n});\r\nconst prepareCreatePayload = (storage, folderUid, recordData) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (!clientId) {\r\n        throw new Error('Client Id is missing from the configuration');\r\n    }\r\n    const ownerPublicKey = yield storage.getBytes(KEY_OWNER_PUBLIC_KEY);\r\n    if (!ownerPublicKey) {\r\n        throw new Error('Application owner public key is missing from the configuration');\r\n    }\r\n    const recordBytes = exports.platform.stringToBytes(JSON.stringify(recordData));\r\n    const recordKey = exports.platform.getRandomBytes(32);\r\n    const recordUid = exports.platform.getRandomBytes(16);\r\n    const encryptedRecord = yield exports.platform.encryptWithKey(recordBytes, recordKey);\r\n    const encryptedRecordKey = yield exports.platform.publicEncrypt(recordKey, ownerPublicKey);\r\n    const encryptedFolderKey = yield exports.platform.encrypt(recordKey, folderUid);\r\n    return {\r\n        clientVersion: 'ms' + packageVersion,\r\n        clientId: clientId,\r\n        recordUid: webSafe64FromBytes(recordUid),\r\n        recordKey: exports.platform.bytesToBase64(encryptedRecordKey),\r\n        folderUid: folderUid,\r\n        folderKey: exports.platform.bytesToBase64(encryptedFolderKey),\r\n        data: webSafe64FromBytes(encryptedRecord)\r\n    };\r\n});\r\nconst postFunction = (url, transmissionKey, payload, allowUnverifiedCertificate) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return exports.platform.post(url, payload.payload, {\r\n        PublicKeyId: transmissionKey.publicKeyId.toString(),\r\n        TransmissionKey: exports.platform.bytesToBase64(transmissionKey.encryptedKey),\r\n        Authorization: `Signature ${exports.platform.bytesToBase64(payload.signature)}`\r\n    }, allowUnverifiedCertificate);\r\n});\r\nconst generateTransmissionKey = (storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const transmissionKey = exports.platform.getRandomBytes(32);\r\n    const keyNumberString = yield storage.getString(KEY_SERVER_PUBIC_KEY_ID);\r\n    const keyNumber = keyNumberString ? Number(keyNumberString) : 7;\r\n    const keeperPublicKey = keeperPublicKeys[keyNumber];\r\n    if (!keeperPublicKey) {\r\n        throw new Error(`Key number ${keyNumber} is not supported`);\r\n    }\r\n    const encryptedKey = yield exports.platform.publicEncrypt(transmissionKey, keeperPublicKeys[keyNumber]);\r\n    return {\r\n        publicKeyId: keyNumber,\r\n        key: transmissionKey,\r\n        encryptedKey: encryptedKey\r\n    };\r\n});\r\nconst encryptAndSignPayload = (storage, transmissionKey, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const payloadBytes = exports.platform.stringToBytes(JSON.stringify(payload));\r\n    const encryptedPayload = yield exports.platform.encryptWithKey(payloadBytes, transmissionKey.key);\r\n    const signatureBase = Uint8Array.of(...transmissionKey.encryptedKey, ...encryptedPayload);\r\n    const signature = yield exports.platform.sign(signatureBase, KEY_PRIVATE_KEY, storage);\r\n    return { payload: encryptedPayload, signature };\r\n});\r\nconst postQuery = (options, path, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const hostName = yield options.storage.getString(KEY_HOSTNAME);\r\n    if (!hostName) {\r\n        throw new Error('hostname is missing from the configuration');\r\n    }\r\n    const url = `https://${hostName}/api/rest/sm/v1/${path}`;\r\n    while (true) {\r\n        const transmissionKey = yield generateTransmissionKey(options.storage);\r\n        const encryptedPayload = yield encryptAndSignPayload(options.storage, transmissionKey, payload);\r\n        const response = yield (options.queryFunction || postFunction)(url, transmissionKey, encryptedPayload, options.allowUnverifiedCertificate);\r\n        if (response.statusCode !== 200) {\r\n            let errorMessage;\r\n            if (response.data) {\r\n                errorMessage = exports.platform.bytesToString(response.data.slice(0, 1000));\r\n                try {\r\n                    const errorObj = JSON.parse(errorMessage);\r\n                    if (errorObj.error === 'key') {\r\n                        yield options.storage.saveString(KEY_SERVER_PUBIC_KEY_ID, errorObj.key_id.toString());\r\n                        continue;\r\n                    }\r\n                }\r\n                catch (_a) {\r\n                }\r\n            }\r\n            else {\r\n                errorMessage = `unknown ksm error, code ${response.statusCode}`;\r\n            }\r\n            throw new Error(errorMessage);\r\n        }\r\n        return response.data\r\n            ? exports.platform.decryptWithKey(response.data, transmissionKey.key)\r\n            : new Uint8Array();\r\n    }\r\n});\r\nconst decryptRecord = (record, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const decryptedRecord = yield exports.platform.decrypt(exports.platform.base64ToBytes(record.data), record.recordUid || KEY_APP_KEY, storage);\r\n    const keeperRecord = {\r\n        recordUid: record.recordUid,\r\n        data: JSON.parse(exports.platform.bytesToString(decryptedRecord)),\r\n        revision: record.revision\r\n    };\r\n    if (record.files) {\r\n        keeperRecord.files = [];\r\n        for (const file of record.files) {\r\n            yield exports.platform.unwrap(exports.platform.base64ToBytes(file.fileKey), file.fileUid, record.recordUid);\r\n            const decryptedFile = yield exports.platform.decrypt(exports.platform.base64ToBytes(file.data), file.fileUid);\r\n            keeperRecord.files.push({\r\n                fileUid: file.fileUid,\r\n                data: JSON.parse(exports.platform.bytesToString(decryptedFile)),\r\n                url: file.url,\r\n                thumbnailUrl: file.thumbnailUrl\r\n            });\r\n        }\r\n    }\r\n    return keeperRecord;\r\n});\r\nconst fetchAndDecryptSecrets = (options, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const storage = options.storage;\r\n    const payload = yield prepareGetPayload(storage, recordsFilter);\r\n    const responseData = yield postQuery(options, 'get_secret', payload);\r\n    const response = JSON.parse(exports.platform.bytesToString(responseData));\r\n    const records = [];\r\n    let justBound = false;\r\n    if (response.encryptedAppKey) {\r\n        justBound = true;\r\n        yield exports.platform.unwrap(exports.platform.base64ToBytes(response.encryptedAppKey), KEY_APP_KEY, KEY_CLIENT_KEY, storage);\r\n        yield storage.delete(KEY_CLIENT_KEY);\r\n        yield storage.saveString(KEY_OWNER_PUBLIC_KEY, response.appOwnerPublicKey);\r\n    }\r\n    if (response.records) {\r\n        for (const record of response.records) {\r\n            if (record.recordKey) {\r\n                yield exports.platform.unwrap(exports.platform.base64ToBytes(record.recordKey), record.recordUid, KEY_APP_KEY, storage, true);\r\n            }\r\n            const decryptedRecord = yield decryptRecord(record, storage);\r\n            records.push(decryptedRecord);\r\n        }\r\n    }\r\n    if (response.folders) {\r\n        for (const folder of response.folders) {\r\n            yield exports.platform.unwrap(exports.platform.base64ToBytes(folder.folderKey), folder.folderUid, KEY_APP_KEY, storage, true);\r\n            for (const record of folder.records) {\r\n                yield exports.platform.unwrap(exports.platform.base64ToBytes(record.recordKey), record.recordUid, folder.folderUid);\r\n                const decryptedRecord = yield decryptRecord(record);\r\n                decryptedRecord.folderUid = folder.folderUid;\r\n                records.push(decryptedRecord);\r\n            }\r\n        }\r\n    }\r\n    let appData;\r\n    if (response.appData) {\r\n        appData = JSON.parse(exports.platform.bytesToString(yield exports.platform.decrypt(webSafe64ToBytes(response.appData), KEY_APP_KEY)));\r\n    }\r\n    const secrets = {\r\n        appData: appData,\r\n        expiresOn: response.expiresOn > 0 ? new Date(response.expiresOn) : undefined,\r\n        records: records\r\n    };\r\n    if (response.warnings && response.warnings.length > 0) {\r\n        secrets.warnings = response.warnings;\r\n    }\r\n    return { secrets, justBound };\r\n});\r\nconst getClientId = (clientKey) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientKeyHash = yield exports.platform.hash(webSafe64ToBytes(clientKey), CLIENT_ID_HASH_TAG);\r\n    return exports.platform.bytesToBase64(clientKeyHash);\r\n});\r\nconst initializeStorage = (storage, oneTimeToken, hostName) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const tokenParts = oneTimeToken.split(':');\r\n    let host, clientKey;\r\n    if (tokenParts.length === 1) {\r\n        if (!hostName) {\r\n            throw new Error('The hostname must be present in the token or as a parameter');\r\n        }\r\n        host = hostName;\r\n        clientKey = oneTimeToken;\r\n    }\r\n    else {\r\n        host = {\r\n            US: 'keepersecurity.com',\r\n            EU: 'keepersecurity.eu',\r\n            AU: 'keepersecurity.com.au',\r\n            GOV: 'govcloud.keepersecurity.us'\r\n        }[tokenParts[0].toUpperCase()];\r\n        if (!host) {\r\n            host = tokenParts[0];\r\n        }\r\n        clientKey = tokenParts[1];\r\n    }\r\n    const clientKeyBytes = webSafe64ToBytes(clientKey);\r\n    const clientKeyHash = yield exports.platform.hash(clientKeyBytes, CLIENT_ID_HASH_TAG);\r\n    const clientId = exports.platform.bytesToBase64(clientKeyHash);\r\n    const existingClientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (existingClientId) {\r\n        if (existingClientId === clientId) {\r\n            return; // the storage is already initialized\r\n        }\r\n        throw new Error(`The storage is already initialized with a different client Id (${existingClientId})`);\r\n    }\r\n    yield storage.saveString(KEY_HOSTNAME, host);\r\n    yield storage.saveString(KEY_CLIENT_ID, clientId);\r\n    yield exports.platform.importKey(KEY_CLIENT_KEY, clientKeyBytes, storage);\r\n    yield exports.platform.generatePrivateKey(KEY_PRIVATE_KEY, storage);\r\n});\r\nconst getSecrets = (options, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    exports.platform.cleanKeyCache();\r\n    const { secrets, justBound } = yield fetchAndDecryptSecrets(options, recordsFilter);\r\n    if (justBound) {\r\n        try {\r\n            yield fetchAndDecryptSecrets(options, recordsFilter);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n    return secrets;\r\n});\r\nconst updateSecret = (options, record) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const payload = yield prepareUpdatePayload(options.storage, record);\r\n    yield postQuery(options, 'update_secret', payload);\r\n});\r\nconst createSecret = (options, folderUid, recordData) => __awaiter(void 0, void 0, void 0, function* () {\r\n    if (!exports.platform.hasKeysCached()) {\r\n        yield getSecrets(options); // need to warm up keys cache before posting a record\r\n    }\r\n    const payload = yield prepareCreatePayload(options.storage, folderUid, recordData);\r\n    yield postQuery(options, 'create_secret', payload);\r\n    return payload.recordUid;\r\n});\r\nconst downloadFile = (file) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const fileResponse = yield exports.platform.get(file.url, {});\r\n    return exports.platform.decrypt(fileResponse.data, file.fileUid);\r\n});\r\nconst downloadThumbnail = (file) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const fileResponse = yield exports.platform.get(file.thumbnailUrl, {});\r\n    return exports.platform.decrypt(fileResponse.data, file.fileUid);\r\n});\n\nfunction getValue(secrets, notation) {\r\n    const schemaNotation = notation.split('://');\r\n    if (schemaNotation.length > 1) {\r\n        if (schemaNotation[0] !== 'keeper') {\r\n            throw Error(`Invalid notation schema: ${schemaNotation[0]}`);\r\n        }\r\n        notation = notation.slice(9);\r\n    }\r\n    const notationParts = notation.split('/');\r\n    if (notationParts.length < 3) {\r\n        throw Error(`Invalid notation ${notation}`);\r\n    }\r\n    const record = secrets.records.find(x => x.recordUid === notationParts[0]);\r\n    if (!record) {\r\n        throw Error(`Record ${notationParts[0]} not found`);\r\n    }\r\n    let fields;\r\n    switch (notationParts[1]) {\r\n        case 'field':\r\n            fields = record.data.fields;\r\n            break;\r\n        case 'custom_field':\r\n            fields = record.data.custom;\r\n            break;\r\n        case 'file':\r\n            const fileId = notationParts[2];\r\n            const file = (record.files || []).find(x => x.data.title === fileId || x.data.name === fileId);\r\n            if (!file) {\r\n                throw Error(`File ${fileId} not found in the record ${record.recordUid}`);\r\n            }\r\n            return file;\r\n        default:\r\n            throw Error(`Expected /field or /custom_field but found /${notationParts[1]}`);\r\n    }\r\n    const findField = (fieldName) => {\r\n        const field = fields.find(x => x.label === fieldName || x.type === fieldName);\r\n        if (!field) {\r\n            throw Error(`Field ${fieldName} not found in the record ${record.recordUid}`);\r\n        }\r\n        return field;\r\n    };\r\n    if (notationParts[2].endsWith('[]')) {\r\n        return findField(notationParts[2].slice(0, -2)).value;\r\n    }\r\n    const fieldParts = notationParts[2]\r\n        .replace(/[\\[\\]]/g, '/')\r\n        .split('/')\r\n        .filter(x => x);\r\n    const field = findField(fieldParts[0]);\r\n    if (fieldParts.length === 1) {\r\n        return field.value[0];\r\n    }\r\n    const fieldValueIdx = parseInt(fieldParts[1]);\r\n    if (isNaN(fieldValueIdx)) {\r\n        return field.value[0][fieldParts[1]];\r\n    }\r\n    if (fieldValueIdx < 0 || fieldValueIdx >= field.value.length) {\r\n        throw Error(`The index ${fieldValueIdx} for field value of ${fieldParts[0]} in the record ${record.recordUid} is out of range (${field.value.length - 1})`);\r\n    }\r\n    return fieldParts.length === 2\r\n        ? field.value[fieldValueIdx]\r\n        : field.value[fieldValueIdx][fieldParts[2]];\r\n}\n\nconst localConfigStorage = (configName) => {\r\n    const readStorage = () => {\r\n        if (!configName) {\r\n            return {};\r\n        }\r\n        try {\r\n            return JSON.parse(fs__namespace.readFileSync(configName).toString());\r\n        }\r\n        catch (e) {\r\n            return {};\r\n        }\r\n    };\r\n    const storageData = readStorage();\r\n    const storage = inMemoryStorage(storageData);\r\n    const saveStorage = (storage) => {\r\n        if (!configName) {\r\n            return;\r\n        }\r\n        fs__namespace.writeFileSync(configName, JSON.stringify(storageData, null, 2));\r\n    };\r\n    return {\r\n        getString: storage.getString,\r\n        saveString: (key, value) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.saveString(key, value);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        }),\r\n        getBytes: storage.getBytes,\r\n        saveBytes: (key, value) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.saveBytes(key, value);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        }),\r\n        delete: (key) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.delete(key);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        })\r\n    };\r\n};\r\nconst cachingPostFunction = (url, transmissionKey, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const response = yield exports.platform.post(url, payload.payload, {\r\n            PublicKeyId: transmissionKey.publicKeyId.toString(),\r\n            TransmissionKey: exports.platform.bytesToBase64(transmissionKey.encryptedKey),\r\n            Authorization: `Signature ${exports.platform.bytesToBase64(payload.signature)}`\r\n        });\r\n        if (response.statusCode == 200) {\r\n            fs__namespace.writeFileSync('cache.dat', Buffer.concat([transmissionKey.key, response.data]));\r\n        }\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        let cachedData;\r\n        try {\r\n            cachedData = fs__namespace.readFileSync('cache.dat');\r\n        }\r\n        catch (_a) {\r\n        }\r\n        if (!cachedData) {\r\n            throw new Error('Cached value does not exist');\r\n        }\r\n        transmissionKey.key = cachedData.slice(0, 32);\r\n        return {\r\n            statusCode: 200,\r\n            data: cachedData.slice(32),\r\n            headers: []\r\n        };\r\n    }\r\n});\n\nconnectPlatform(nodePlatform);\r\ninitialize();\n\nexports.cachingPostFunction = cachingPostFunction;\nexports.connectPlatform = connectPlatform;\nexports.createSecret = createSecret;\nexports.downloadFile = downloadFile;\nexports.downloadThumbnail = downloadThumbnail;\nexports.generatePassword = generatePassword;\nexports.generateTransmissionKey = generateTransmissionKey;\nexports.getClientId = getClientId;\nexports.getSecrets = getSecrets;\nexports.getTotpCode = getTotpCode;\nexports.getValue = getValue;\nexports.inMemoryStorage = inMemoryStorage;\nexports.initialize = initialize;\nexports.initializeStorage = initializeStorage;\nexports.loadJsonConfig = loadJsonConfig;\nexports.localConfigStorage = localConfigStorage;\nexports.updateSecret = updateSecret;\n//# sourceMappingURL=index.cjs.js.map\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(109);\n",""],"names":[],"sourceRoot":""}